import vertexShader from './shader.vert'
import fragmentShader from './shader.frag'

import mat4 from 'tsm/src/mat4'
import vec3 from 'tsm/src/vec3'

//List where each index n specifies how many times a stem generate a clone on
//average for a stem with n parents.
const STEM_BRANCHING_FACTORS: number[] = [1, 1, 1, 1, 0];

//List where each index n specifies how many non-clone branches may be
//generated by each branch with n parents.
const BRANCHING_FACTORS: number[] = [0, 2, 3, 4, 1, 1];

var canvas : HTMLCanvasElement, gl;

var treeMesh, shaderProgram, mvpLocation, worldLocation;

let leftPressed = false;
let rightPressed = false;
let upPressed = false;
let downPressed = false;

function handleKeyEvent(keyCode: string, newState: boolean) {
    switch (keyCode) {
        case "KeyA":
        case "ArrowLeft":
            leftPressed = newState;
            break;
        case "KeyD":
        case "ArrowRight":
            rightPressed = newState;
            break;
        case "KeyW":
        case "ArrowUp":
            upPressed = newState;
            break;
        case "KeyS":
        case "ArrowDown":
            downPressed = newState;
            break;
    }    
}

window.addEventListener('keydown', (event) => {
    handleKeyEvent(event.code, true);
    event.preventDefault();
}, true);

window.addEventListener('keyup', (event) => {
    handleKeyEvent(event.code, false);
    event.preventDefault();
}, true);

interface Resource {
    filename: string;
    contents: string;
}

interface Branch {
    endPoint: vec3;
    children: Branch[];
}

let testTree = {
    endPoint: new vec3([0, 1, 0]),
    children: [
        { endPoint: new vec3([0.5, 2, 0.5]), children: [] },
        { endPoint: new vec3([-0.1, 2, 0]), children: [] }
    ]
}

let cameraPositionAngle = 0;
let cameraPositionRadius = 2;
let y = 3;

let lastRenderTime = 0;
function render(time: number): void {
    let dt = Math.min((time - lastRenderTime) / 1000, 1 / 30);
    lastRenderTime = time;

    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    let proj = mat4.perspective(45, canvas.width / canvas.height, 0.1, 100);

    let angularVelocity = 0;
    if (leftPressed) {
        angularVelocity -= 2;
    }
    if (rightPressed) {
        angularVelocity += 2;
    }
    cameraPositionAngle += angularVelocity * dt;

    let vy = 0;
    if (upPressed) {
        vy += 2;
    }
    if (downPressed) {
        vy -= 2;
    }
    y += vy * dt;

    let camPosX = Math.sin(cameraPositionAngle) * cameraPositionRadius;
    let camPosZ = Math.cos(cameraPositionAngle) * cameraPositionRadius;
    let cameraTarget = new vec3([0, 1, 0]);

    let viewMatrix = mat4.lookAt(
        new vec3([camPosX, y, camPosZ]),
        cameraTarget,
        new vec3([0, 1, 0])
    );
    proj.multiply(viewMatrix);

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.useProgram(shaderProgram);
    gl.bindVertexArray(treeMesh.vao);
    gl.uniformMatrix4fv(worldLocation, false, mat4.identity.all());
    gl.uniformMatrix4fv(mvpLocation, false, proj.all());
    gl.drawElements(gl.TRIANGLES, treeMesh.indexAmount, gl.UNSIGNED_SHORT, 0);

    requestAnimationFrame(render);
}

interface BranchVertexData {
    position: vec3;
    normal: vec3;
}

interface BranchMeshPart {
    vertices: BranchVertexData[];
    indices: Uint16Array;
}

let branchSideIndices = [0, 1, 2, 1, 2, 3];
let BRANCH_RESOLUTION = 8; // Number of vertices on each side of a branch
let BRANCH_INDEX_AMOUNT = branchSideIndices.length * BRANCH_RESOLUTION;
let BRANCH_VERTEX_AMOUNT = BRANCH_RESOLUTION * 2; // Two ends on each branch

function generateBranchData(startPoint: vec3, endPoint: vec3): BranchMeshPart {
    let meshPart = {
        vertices: new Array<BranchVertexData>(BRANCH_VERTEX_AMOUNT),
        indices: new Uint16Array(BRANCH_INDEX_AMOUNT)
    };

    for (let i = 0; i < BRANCH_RESOLUTION; i++) {
        let angle = i / BRANCH_RESOLUTION * (2 * Math.PI);
        let x = Math.cos(angle) * 0.1;
        let z = Math.sin(angle) * 0.1;

        meshPart.vertices[i * 2] = {
            position: new vec3([startPoint.x + x, startPoint.y, startPoint.z + z]),
            normal: new vec3([x, 0, z])
        };

        meshPart.vertices[i * 2 + 1] = {
            position: new vec3([endPoint.x + x, endPoint.y, endPoint.z + z]),
            normal: new vec3([x, 0, z])
        }

        meshPart.indices.set(
            branchSideIndices.map(b => (b + i * 2) % 16),
            i * branchSideIndices.length
        );
    }

    return meshPart;
}

function generateAllMeshParts(tree: Branch, startPoint: vec3): BranchMeshPart[] {
    let thisData = generateBranchData(startPoint, tree.endPoint);
    let childrenData: BranchMeshPart[] = tree.children.flatMap(
        c => generateAllMeshParts(c, tree.endPoint)
    );
    return childrenData.concat(thisData);
}

interface Mesh {
    vao: WebGLVertexArrayObject;
    indexAmount: number;
}

function createTreeMesh(tree: Branch): Mesh {
    let meshParts = generateAllMeshParts(testTree, new vec3([0, 0, 0]));

    let branchAmount = meshParts.length;
    let DATA_PER_VERTEX = 6; // x, y and z coords for both position and normal
    let VERTEX_ARRAY_SIZE = BRANCH_VERTEX_AMOUNT * branchAmount * DATA_PER_VERTEX;
    let numIndices = BRANCH_INDEX_AMOUNT * branchAmount;

    let vertexData = new Float32Array(VERTEX_ARRAY_SIZE);
    let indices = new Uint16Array(numIndices);

    // Indices need to be offset based on their position in the final array
    for (let i = 0; i < meshParts.length; i++) {
        let indexIndex = i * BRANCH_INDEX_AMOUNT;
        let vertexIndex = i * BRANCH_VERTEX_AMOUNT;
        let part = meshParts[i];
        indices.set(
            part.indices.map(ind => ind + vertexIndex), indexIndex
        );

        for (let j = 0; j < part.vertices.length; j++) {
            let vertex = part.vertices[j];
            let thisData = vertex.position.xyz.concat(vertex.normal.xyz);
            vertexData.set(thisData, (vertexIndex + j) * DATA_PER_VERTEX);
        }
    }

    let vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    let buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

    let pos_location = gl.getAttribLocation(shaderProgram, "a_position");
    let norm_location = gl.getAttribLocation(shaderProgram, "a_normal");
    gl.enableVertexAttribArray(pos_location);
    gl.enableVertexAttribArray(norm_location);

    // Normals come after positions in the array
    let size = 3, normalize = false, stride = DATA_PER_VERTEX * 4;
    gl.vertexAttribPointer(pos_location, size, gl.FLOAT, normalize, stride, 0);
    gl.vertexAttribPointer(norm_location, size, gl.FLOAT, normalize, stride, 12);

    // Buffer indices
    let indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    return {vao: vao, indexAmount: numIndices };
}

/**
 * Compiles a shader to be used in a GPU program.
 * @param {number} type - The type of shader. gl.VERTEX_SHADER/gl.FRAGMENT_SHADER/etc
 * @param {string} source - The shader source code.
 * @returns {WebGLShader} The OpenGL shader id of the compiled shader
 */
function createShader(type: number, source: string): WebGLShader {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    // Log an error if the compilation fails
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    if (success) {
        return shader;
    } else {
        console.log(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
}

function createProgram(shaderSources: Array<Resource>): WebGLProgram {
    let shaderTypes = {
        "shader.vert": gl.VERTEX_SHADER,
        "shader.frag": gl.FRAGMENT_SHADER
    };

    var program = gl.createProgram();
    for (let shaderData of shaderSources) {
        let shader = createShader(
            shaderTypes[shaderData.filename],
            shaderData.contents
        );
        gl.attachShader(program, shader);
    }
    gl.linkProgram(program);

    // Log an error if the compilation failed
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
        return program;
    } else {
        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
    }
}

function onLoad(): void {
    canvas = document.querySelector("#glCanvas");
    gl = canvas.getContext("webgl2");

    if (gl === null) {
        alert("Unable to initialize WebGL");
        return;
    }

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    shaderProgram = createProgram([
        { filename: "shader.vert", contents: vertexShader },
        { filename: "shader.frag", contents: fragmentShader }
    ]);

    treeMesh = createTreeMesh(testTree);
    mvpLocation = gl.getUniformLocation(shaderProgram, "mvp");
    worldLocation = gl.getUniformLocation(shaderProgram, "world");

    requestAnimationFrame(render);
}

window.onload = () => onLoad();
